# Redux

- [Redux 역사](#Redux-역사)
- [Flux의 탄생](#Flux의-탄생)
- [Flux와 Redux의 차이점](#Flux와-Redux의-차이점)
- [Redux의 기본개념 핵심 키워드](#redux-기본개념-핵심-키워드)

<hr>

## Redux 역사

### MVC 아키텍처의 한계

Redux를 이해하기 전 MVC에 대해 먼저 알아야 한다.

<img src="https://tech.osci.kr/wp-content/uploads/2022/05/f69de6f3-d975-40f8-b482-1454679991b8.png">
출처: Flux 공식문서

MVC 패턴에서 Controller는 Model에 정의된 데이터를 조회하거나 업데이트하는 역할을 하며, 변경된 Model의 데이터를 view에 반영해 주고 또한 사용자는 View를 통해 데이터를 입혁하고 Model에 반영되며, View와 Model은 데이터를 양방향으로 주고받는 형태이다.

<img src="https://tech.osci.kr/wp-content/uploads/2022/05/18a0ce60-1fdc-45b2-b0d9-0e739bfbb038-1.png">

하지만 이 패턴에 문제점이 있다. 프로젝트 규모가 커질수록 수많은 View와 Model들이 생겨나게 되고 데이터가 어디로 흐르는지 파악하기 어렵다. 이러한 이유로 새 기능을 추가할 때 마다 크고 작은 문제가 생겼으며 예기치 못한 결과(Side Effect)를 불러 일으켰다.

## Flux의 탄생

<img src="https://tech.osci.kr/wp-content/uploads/2022/05/fb82ab33-baa2-4bba-aaa7-ed81657bdbc6.png">

MVC 패턴에 문제를 해결하기 위해 나온 것이 Flux 패턴이다.
Flux 패턴은 어떤 Acction이 발생하면 dispatcher에 의해 store에 변경된 사항이 저장되고 그 저장된 데이터들에 의해 view가 변경되는 단반향 패턴이다. 이러한 패턴의 가장 큰 장점은 단반향으로 흐르기 때문에 흐름을 훨씬 파악하기 쉽고 예측 가능(predictable)하다는 것이다.

이러한 Flux 패턴을 적용한 많은 구현체 중 하나가 바로 Redux이다.

## Flux와 Redux의 차이점

차이점은 Flux에서 존재했던 문제점에 대해 비교해보자

1. Hot Reloading
   Hot Reloading이란 코드가 변경되어도 기존의 상태를 유지할 수 있게 만들어 주는 것이다. Flux의 첫 번째 문제점으로는 상태 업데이트에 관련된 코드를 리로딩하게 되면 애플리케이션 상태도 같이 리로딩되어 저장된 상태 정보를 잃어버리게 되는 것이다. 이것은 store가 두 가지 역할을 맡고 있기 때문인데 1. 상태(state)변환을 위한 로직 2.현재 애플리케이션의 상태(state)

Redux가 유용한 점이 바로 두 가지 역할을 분리함으로써 상태 변환 로직을 핫 리로딩할 수 있다는 것이다. Redux에서는 store가 애플리케이션 상태를 가지며, 상태 변환 로직은 reducer가 관리를 한다 즉, 리듀서를 리로딩하는 것으로 애플리케이션 상태를 잃어버리자않고 관련 로직만을 핫 리로딩 할 수 있다.

2. Time Travel Debugging
   시간 여행 디버깅이란 이전의 특정 상태로 돌아갈 수 있게 해주는 거. 이 것이 가능하기 위해서는 상태가 새로 바뀔 때마다 상태 객체의 모든 버전을 기록해 두어야 하는데 Redux는 이 문제를 해결하기 위해 기존의 애플리케이션 상태를 직접 수정하는 대신 그 상태를 복사하여 복사본을 수정하는 식으로 불변성을 유지 이는 Flux에서도 구현 가능하지만 상당히 복잡한 반면 Redux에서는 아주 간단히 이를 처리 할 수 있다.

## Redux의 사용 이유

규모가 큰 프로젝트인 경우 컴포넌트 개수도 많아지고 그에 따라 관리해야 하는 state들도 많아져 복잡해진다.
React에서의 데이터가 공유되는 방식은 부모 컴포넌트에서 자식 컴포넌트로 데이터가 흐르는 단반향 패턴이며 자식 컴포넌트들 간의 다이렉트 데이터 전달은 불가능하다. 이러한 공유 과정은 코드를 지저분하게하며 유지보수도 어려워지게 된다.

## Redux 기본개념 핵심 키워드

1. Single Soure of truth: 하나의 어플리케이션은 하나의 store만 가진다.

동일한 데이터는 store라는 하나뿐인 데이터 공간에서 관리되고 이렇게 하면 애플리케이션의 디버깅이 쉬워진다 또한 서버와의 직렬화가 가능하며 클라이언트에서 데이터를 쉽게 받아 들여올 수 있다.

2. State is read-only : 상태는 읽기 전용이다.

state를 직접 변경해서는 안되며 state의 변경은 오직 reducer에서만 할 수 있다. reducer이외 공간에서의 state는 읽기 전용인 것이며 이것이 바로 데이터의 단방향 흐름의 이점으로 상태를 변화시키는 의도를 정확히 표현 가능하며 상태 변경에 대한 추적도 용이하다.

3. Changes are made with pure functions : 리듀서는 순수 함수여야 한다.

reducer는 순수 함수여야만 한다. reducer 함수는 기존의 state를 직접 변경하지 않고, 새로운 state object를 작성해서 return 해야 한다. 동일한 파라미터로 호출 된 reducer는 순수함수이기 때문에 언제나 같은 결과값만 반환한다.

### 핵심 키워드

1. Store(스토어) : 상태가 관리되는 오직 하나의 공간을 말하며 앱에서 필요한 상태들과 리듀서가 저장되어 있으며 컴포넌트에서 상태 정보가 필요할 때 스토어에 접근한다.

2. Action(액션) : Action은 상태를 변화시키려는 의도를 표현한 객체이며 변경할 때 어떠한 변화를 줄지 해당하는 액션을 발생시킬 수 있다.

3. Action Creator(액션 생성 함수) : Aciton을 생성해 실제 객체로 만들어 주는 함수.

4. Reducer(리듀서) : Action을 통해 그 결과 어플리케이션의 상태가 어떻게 바뀌는지 특정하는 즉, state에 변화를 일으키는 함수.

리듀서는 현재의 state와 action을 인자로 받아 store에 접근 액션에 맞춰 스테이트를 변경한다. 순수함수임을 지켜야하는 원칙이 있으므로 이전 상태 건드리지 않고 변화된 새로운 상태 객체를 만들어 반화 핫리로딩과 시간여행과 같은 멋진 기능이 가능하게 해 줌.

5. Dispatch(디스패치) : store의 내장 함수 중 하나로 액션을 발생시키고 액션을 파라미터로 전달해 리듀서를 호출.

6. Subsrible(구독) : store의 내장 함수 중 하나로, 특정 함수를 전달하면 action이 dispatch 되었을 때마다 전달된 함수가 호출.
